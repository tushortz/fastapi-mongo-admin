<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resell Studio Admin</title>
    <!-- Figtree and Inter Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Figtree:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Theme CSS -->
    <link rel="stylesheet" href="css/lightmode.css" id="theme-stylesheet">
    <!-- Apply dark mode immediately to prevent flicker -->
    <script>
      (function () {
        // Apply dark mode synchronously before page renders
        // This prevents flicker when page reloads (e.g., on language change)
        try {
          const darkMode = localStorage.getItem('darkMode') === 'true';
          const html = document.documentElement;
          const themeStylesheet = document.getElementById('theme-stylesheet');

          // Apply dark mode class to html element immediately
          if (darkMode) {
            html.classList.add('dark');
            if (themeStylesheet) {
              themeStylesheet.href = 'css/darkmode.css';
            }
          } else {
            html.classList.remove('dark');
            if (themeStylesheet) {
              themeStylesheet.href = 'css/lightmode.css';
            }
          }

          // Apply to body when it's available (using DOMContentLoaded as fallback)
          if (document.body) {
            if (darkMode) {
              document.body.classList.add('dark');
            } else {
              document.body.classList.remove('dark');
            }
          } else {
            // If body doesn't exist yet, wait for DOMContentLoaded
            document.addEventListener('DOMContentLoaded', function () {
              if (darkMode) {
                document.body.classList.add('dark');
              } else {
                document.body.classList.remove('dark');
              }
            });
          }
        } catch (e) {
          // Silently fail if localStorage is not available
        }
      })();
    </script>
    <!-- React and ReactDOM - Local files for offline support -->
    <script src="js/react.production.min.js"></script>
    <script src="js/react-dom.production.min.js"></script>

    <!-- Babel Standalone for JSX transformation - Local file for offline support -->
    <script src="js/babel.min.js"></script>

    <!-- Tailwind CSS CDN -->
    <script>
      (function() {
        if (typeof console !== 'undefined') {
          // Console methods removed
          const originalWarn = function () { };
          const originalError = function () { };
          const originalLog = function () { };

          // Console methods disabled
          console.warn = function () { };
          console.error = function () { };
          console.log = function () { };
        }
      })();
    </script>
    <script src="css/tailwind.css"></script>

    <!-- Chart.js CDN -->
    <script src="js/chart.umd.min.js"></script>

    <style>
      * {
        font-family: 'Figtree', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      }

      code, pre, .font-mono, textarea[class*="font-mono"] {
        font-family: 'Courier New', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace !important;
      }

      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .modal.active .modal-content {
        animation: modalSlideIn 0.3s ease-out;
      }

      .collection-item.expanded .collection-arrow {
        transform: rotate(90deg);
      }
    </style>
</head>

<body class="h-screen overflow-hidden bg-gray-100 text-gray-800 font-sans">
  <div id="root"></div>

    <!-- React Application - Load modules with Babel JSX transformation -->
    <!-- Note: Babel Standalone transforms JSX but imported modules also need transformation -->
    <!-- This script handles transforming all modules recursively -->
    <script type="module">
          const moduleCache = new Map();

          async function loadTransformedModule(url, base = location.href) {
            const resolvedUrl = new URL(url, base).href;
            if (moduleCache.has(resolvedUrl)) {
              return moduleCache.get(resolvedUrl);
        }

          const response = await fetch(resolvedUrl);
          let code = await response.text();

          // Transform JSX to React.createElement
          const transformed = Babel.transform(code, {
            presets: ['react'],
            filename: resolvedUrl
          }).code;

          // Find and transform all relative imports (both ./ and ../)
          // Match various import formats:
          // - import { x } from './path'
          // - import x from './path'
          // - import * as x from './path'
          // - import './path' (side-effect import)
          const importPattern = /import\s+(?:(?:\{[^}]*\}|\*\s+as\s+\w+|\w+)(?:\s*,\s*(?:\{[^}]*\}|\*\s+as\s+\w+|\w+))*\s+from\s+)?['"](\.\.?\/[^'"]+)['"]/g;
          const imports = [];
          let match;
          const processedIndices = new Set();

          while ((match = importPattern.exec(transformed)) !== null) {
            // Avoid processing the same match twice
            if (processedIndices.has(match.index)) continue;
            processedIndices.add(match.index);

          // The path is in the last capturing group (the one with the quotes)
          // match[0] = full match, match[1] = the path inside quotes
          const importPath = match[1];
          if (importPath && (importPath.startsWith('./') || importPath.startsWith('../'))) {
            imports.push({
              full: match[0],
              path: importPath,
              index: match.index
            });
          }
        }

          // Transform imports in reverse order to maintain indices
          let finalCode = transformed;
          for (let i = imports.length - 1; i >= 0; i--) {
            const imp = imports[i];
            const transformedPath = await loadTransformedModule(imp.path, resolvedUrl);
            // Replace the relative path with the blob URL in the import statement
            // Need to replace the path while keeping the quotes
            const quoteChar = imp.full.includes("'") ? "'" : '"';
            const newImport = imp.full.replace(
              new RegExp(`${quoteChar}${imp.path.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}${quoteChar}`, 'g'),
              `${quoteChar}${transformedPath}${quoteChar}`
            );
          finalCode = finalCode.substring(0, imp.index) +
            newImport +
            finalCode.substring(imp.index + imp.full.length);
        }

          // Create blob and cache
          const blob = new Blob([finalCode], { type: 'application/javascript' });
          const blobUrl = URL.createObjectURL(blob);
          moduleCache.set(resolvedUrl, blobUrl);

          return blobUrl;
        }

          // Load app
          loadTransformedModule('./js/react/App.js')
            .then(url => import(url))
            .then(({ App }) => {
              const root = ReactDOM.createRoot(document.getElementById('root'));
              root.render(React.createElement(App));
            })
            .catch(err => {
              // Failed to load app
            });
    </script>
</body>

</html>
